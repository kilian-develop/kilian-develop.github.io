---
layout: post
title: 레이어드 아키텍처로 인프라에 독립적인 비즈니스 로직 설계
date: 2025-10-19
categories: architecture
tags:
  - architecture
  - domain-driven-design
  - layered-architecture
  - multimodule
excerpt: 도메인 중심 설계를 통해 인프라 변경에 영향받지 않는 비즈니스 로직을 만드는 방법. 멀티모듈 구조와 runtimeOnly 의존성으로 컴파일 타임 격리를 구현하는 실전 가이드입니다.
---
# 하위 레이어에 의존적인 아키텍처
아래 이미지는 서비스를 개발하다 보면 흔히들 볼 수 있는 소프트웨어 아키텍처의 구조입니다.

![레이어드 아키텍쳐](/assets/images/posts/레이어드%20아키텍쳐.png)
많은 블로그의 포스트들이나 문서들이 아래와 같이 설명하고 있습니다.

**레이어드 아키텍처란?**
- 소프트웨어를 **여러 개의 계층으로 분리해서 설계**하는 방법
- 각각 계층이 서로 **독립적으로 구성되어 있어서** 한 계층의 변경이 다른 계층에 영향을 주지 않게 설계할 수 있다.
- 외부의 요구사항이나 세부적인 **구현이 변화하더라도 도메인의 로직을 변경하지 않도록 보호**하기 위해서 계층화를 하게 된다.

하지만 우리가 개발하는 대부분의 코드는 아래와 같습니다.
```java
  @Entity
  @Getter
  @Setter
  public class Order {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      private String orderNumber;
      private BigDecimal totalAmount;
      private LocalDateTime createdAt;

      public Order(String orderNumber, BigDecimal totalAmount) {
          this.orderNumber = orderNumber;
          this.totalAmount = totalAmount;
          this.createdAt = LocalDateTime.now();
      }

      public Order() {}
  }
```

```java
  @Repository
  public interface OrderRepository extends JpaRepository<Order, Long> {
  }
```

```java
  @Service
  @RequiredArgsConstructor
  public class OrderService {
      private final OrderRepository orderRepository;

      public OrderResponse createOrder(String orderNumber, BigDecimal totalAmount) {
          Order order = new Order(orderNumber, totalAmount);
          Order savedOrder = orderRepository.save(order);
          return new OrderResponse(savedOrder);
      }
  }
```

``` java
  @RestController
  @RequestMapping("/api/orders")
  @RequiredArgsConstructor
  public class OrderController {
      private final OrderService orderService;

      @PostMapping
      public OrderResponse createOrder(@RequestParam String orderNumber,
                                       @RequestParam BigDecimal totalAmount) {
          return orderService.createOrder(orderNumber, totalAmount);
      }
  }
```

어떤가요?

위 구현은 **여러개의 계층으로 분리**되어있고, **각각의 계층이 독립적**이며, **구현이 변화하더라도 도메인 로직이 변화하지 않아**도 될까요?

제가 말씀드리고 싶은건 위 코드들은 겉으로만 레이어가 분리된 척! 하고 있다는 것입니다.
제가 여기서 꼬집고 싶은 문제는 세 가지 정도입니다.

1. 서비스 레이어가 `Order`라는 ==JPA 엔티티==에 의존적임.
2. 서비스 레이어가 `OrderResponse`라는 ==DTO==에 의존적임.
3. 서비스 레이어가 `JpaRepository`를 상속 받고 있는 `OrderRepository`에 의존적임.

## JPA 엔티티에 의존적인 서비스
1번과 3번 문제의 주제입니다.
JPA 엔티티는 어떤 레이어에 의존적인 객체일까요? 
저는 당연히 `Persistance`레이어에 의존적인 객체라고 생각했습니다.
이에 대한 의존성은 서비스를 운영하던 중간에 데이터베이스를 MongoDB로 바꿔야 하는 상황이 왔다고 가정해봅시다.
MariaDB(RDB)에서 MongoDB로 변경을 한다고 했을 때, 이 JPA 엔티티는 수정 없이 ==그대로== 사용할 수 있을까요?
저는 아니라고 생각했습니다. `@Entity`, `@Table`과 같은 애노테이션 부터 너무 RDB에 의존적이기 때문이죠.

그럼 이 JPA 엔티티를 Spring Data Mongodb를 통해 MongoDB의 엔티티로 변경한다고 했을때, 비즈니스(서비스) 레이어는 독립적으로 잘 작동할까요?

**아닙니다.**

이미 Order라는 JPA 엔티티안에는 주문을 생성하고, 주문금액을 계산하고 하는 등 많은 비즈니스 로직이 구현되어 있을 겁니다.
그럼 Order 객체를 MongoDB의 엔티티로 변경했을 때, **비즈니스 로직이 변경되지 않을 것이라고 보장할 수 없게 됩니다.**

## 애플리케이션(Contoller, Event Listener .. etc)에 의존적인 서비스
2번 주제의 문제입니다.
우리가 서비스를 운영하면서 같은 비즈니스 로직을 수행하는 서비스의 애플리케이션이 변경된다면 어떻게 될까요?
예를 들어, REST API를 통해 통신을 하던 서비스가 `Kafka`나 `RabbitMQ` 같은 메세지 기반 서비스로 변경이 되야한다면 어떻게 해야할까요? 위 주문 서비스는 `Order Controller`만 변경하면 될까요?

아쉽게도 아닙니다.

이유는 `OrderService`는 `OrderResponse`라는 DTO에 의존중이기 때문입니다.
`OrderResponse`는 뚜렷하게 REST API에 의존적인 객체입니다. API를 호출하는 클라이언트에게 응답할 객체를 서술하고 있으니까요.
`Kafka`로 변경해야 된다면 `OrderService`는 Kafka에 맞게 `OrderEvent`라는 객체를 응답해야할 지 모릅니다.

다음에는 제가 이 문제를 어떻게 해결하고자 했는지를 설명하겠습니다.

---
# 해결책: 도메인 중심 설계

위 문제들의 핵심적인 원인은 **레이어 간의 잘못된 의존성**입니다. 어플리케이션 레이어와 영속성 레이어가 서비스 레이어에 영향을 미치고 있습니다.

**해결 방법은 간단합니다. 서비스 레이어는 도메인 레이어에만 의존하도록 설계하면 됩니다.**

이를 위해서는 **JPA 엔티티와 도메인 객체를 분리**해야 합니다. 도메인과 JPA 엔티티를 분리했을 때의 장점은 다음과 같습니다:

1. **서비스 레이어가 RDB에 의존적이지 않게 구현할 수 있다**
   - 데이터베이스가 MongoDB로 변경되어도 서비스와 도메인은 영향을 받지 않음

2. **DB에 의존적이지 않아, 도메인 설계 시 데이터 중심이 아닌 역할과 책임을 중심으로 설계할 수 있다 (객체지향)**
   - 비즈니스 로직에 집중한 깔끔한 도메인 설계 가능

3. **final 키워드를 활용하여 도메인을 불변으로 할 수 있다**
   - CQS 원칙을 지키고 스레드 안전성을 확보

## 1. 서비스 레이어가 RDB에 의존적이지 않게 구현할 수 있다

**Before: JPA 엔티티에 종속된 서비스**
```java
@Entity
@Getter
@Setter
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String orderNumber;
    private BigDecimal totalAmount;
    private LocalDateTime createdAt;
}

@Service
public class OrderService {
    private final OrderRepository orderRepository;

    public Order createOrder(String orderNumber, BigDecimal totalAmount) {
        Order order = new Order(orderNumber, totalAmount);
        return orderRepository.save(order);
    }
}
```

데이터베이스가 MariaDB에서 MongoDB로 변경된다면 어떻게 될까요? `@Entity`, `@Table`, `@Id` 같은 JPA 애노테이션들을 모두 제거해야 하고, Spring Data MongoDB의 애노테이션으로 전부 변경해야 합니다. 이 과정에서 **OrderService의 비즈니스 로직도 함께 영향을 받게 되어 실수로 비즈니스 로직이 변경될 수 있습니다.**

---

**After: 도메인과 JPA 엔티티를 분리한 경우**

먼저 도메인 객체는 순수하게 비즈니스 로직만 담당합니다:

```java
public class Order {
    private final Long id;
    private final String orderNumber;
    private final BigDecimal totalAmount;
    private final LocalDateTime createdAt;

    public Order(String orderNumber, BigDecimal totalAmount) {
        this.orderNumber = orderNumber;
        this.totalAmount = totalAmount;
        this.createdAt = LocalDateTime.now();
    }

    public String getOrderNumber() { return orderNumber; }
    public BigDecimal getTotalAmount() { return totalAmount; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
```

JPA 엔티티는 순수하게 ORM 매핑만 담당합니다:

```java
@Entity
@Getter
@Setter
public class OrderEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String orderNumber;
    private BigDecimal totalAmount;
    private LocalDateTime createdAt;
}
```

리포지토리 인터페이스를 정의하여 도메인에 의존하도록 합니다:

```java
public interface OrderRepository {
    Order save(Order order);
    Order findById(Long id);
}
```

JPA 구현체는 도메인과 JPA 엔티티 사이의 매핑을 담당합니다:

```java
@Repository
public class OrderRepositoryImpl implements OrderRepository {
    private final OrderJpaRepository jpaRepository;

    @Override
    public Order save(Order order) {
        OrderEntity entity = new OrderEntity();
        entity.setOrderNumber(order.getOrderNumber());
        entity.setTotalAmount(order.getTotalAmount());
        entity.setCreatedAt(order.getCreatedAt());

        OrderEntity saved = jpaRepository.save(entity);
        return new Order(saved.getOrderNumber(), saved.getTotalAmount());
    }

    @Override
    public Order findById(Long id) {
        return jpaRepository.findById(id)
            .map(entity -> new Order(entity.getOrderNumber(), entity.getTotalAmount()))
            .orElseThrow();
    }
}

@Repository
public interface OrderJpaRepository extends JpaRepository<OrderEntity, Long> {
}
```

서비스 레이어는 도메인 인터페이스에만 의존합니다:

```java
@Service
public class OrderService {
    private final OrderRepository orderRepository;

    public Order createOrder(String orderNumber, BigDecimal totalAmount) {
        Order order = new Order(orderNumber, totalAmount);
        return orderRepository.save(order);
    }
}
```

이제 MongoDB로 변경해야 한다면, 구현체만 교체하면 됩니다:

```java
@Repository
public class OrderMongoRepository implements OrderRepository {
    private final OrderMongoDao mongoDao;

    @Override
    public Order save(Order order) {
        OrderDocument doc = new OrderDocument();
        doc.setOrderNumber(order.getOrderNumber());
        doc.setTotalAmount(order.getTotalAmount());
        mongoDao.save(doc);
        return order;
    }

    @Override
    public Order findById(Long id) {
        // MongoDB 조회 로직
        return mongoDao.findById(id).map(/* ... */).orElseThrow();
    }
}
```

**OrderService는 전혀 변경되지 않습니다!** 도메인 객체 Order도 변경되지 않습니다. 
단지 구현체만 MongoDB 버전으로 교체되는 것입니다.

---

## 2. 도메인 설계 시 역할과 책임을 중심으로 설계할 수 있다 (객체지향)

JPA 엔티티는 ORM 도구이므로 **데이터 중심**으로 설계될 수 밖에 없습니다.
반면 도메인 객체는 **역할과 책임 중심**으로 설계할 수 있습니다. 이는 비즈니스 로직에 더 적합합니다.

**Before: 데이터 중심 설계 (JPA 엔티티)**

모든 할인 정책을 하나의 엔티티에 담으려고 하면:

```java
@Entity
@Getter
public class DiscountPolicy {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long orderId;

    // 정액할인 필드
    private BigDecimal fixedDiscountAmount;

    // 정률할인 필드
    private BigDecimal percentageDiscount;

    // 쿠폰할인 필드
    private String couponCode;
    private boolean isCouponExpired;
    private BigDecimal couponDiscountAmount;

    // 할인 타입 구분
    private String discountType;  // "FIXED", "PERCENTAGE", "COUPON"

    private LocalDateTime createdAt;
}
```

이 설계는 데이터베이스 테이블 구조를 그대로 반영합니다. 정액할인, 정률할인, 쿠폰할인 등 다양한 할인 정책을 처리할 때:

- 모든 할인 방식에 대한 필드를 하나의 엔티티에 넣어야 함
- 실제로 필요 없는 필드들도 null로 채워져 있음
- 할인 정책이 추가될 때마다 엔티티에 새로운 필드를 추가해야 함
- 객체지향의 **추상화와 다형성**을 활용하기 매우 어려움

---

**After: 역할과 책임 중심 설계 (도메인)**

기존 JPA 엔티티를 도메인으로 사용하는 경우 DB에 데이터 베이스 구조에 맞춰 위 같이 엔티티안에 필요없는 값들을 포함하여 사용해야 했을 것입니다. 

하지만 도메인으로 구성한다면 데이터베이스의 구조에 상관없이 도메인의 역할과 책임을 기준으로 개발 할 수 있습니다.
아래는 할인이라는 역할을 인터페이스로 추상화하면 문제를 깔끔하게 해결할 수 있습니다:

```java
public interface DiscountPolicy {
    boolean isValid();
    BigDecimal calculateDiscount(BigDecimal originalAmount);
}
```

모든 구현체가 OrderId를 동일하게 관리하므로, 공통 로직을 추상클래스로 분리합니다:

```java
// OrderId를 공통으로 관리하는 추상클래스
public abstract class AbstractDiscountPolicy implements DiscountPolicy {
    protected final Long orderId;

    public AbstractDiscountPolicy(Long orderId) {
        this.orderId = orderId;
    }

    @Override
    public final Long getOrderId() {
        return orderId;
    }
}

public class FixedAmountDiscount extends AbstractDiscountPolicy {
    private final BigDecimal discountAmount;

    public FixedAmountDiscount(Long orderId, BigDecimal discountAmount) {
        super(orderId);
        this.discountAmount = discountAmount;
    }

    @Override
    public boolean isValid() {
        return discountAmount != null && discountAmount.compareTo(BigDecimal.ZERO) > 0;
    }

    @Override
    public BigDecimal calculateDiscount(BigDecimal originalAmount) {
        if (!isValid()) {
            throw new InvalidDiscountException("정액할인 금액이 유효하지 않습니다");
        }
        return discountAmount.min(originalAmount);
    }
}

public class PercentageDiscount extends AbstractDiscountPolicy {
    private final BigDecimal percentage;

    public PercentageDiscount(Long orderId, BigDecimal percentage) {
        super(orderId);
        this.percentage = percentage;
    }

    @Override
    public boolean isValid() {
        return percentage != null
            && percentage.compareTo(BigDecimal.ZERO) > 0
            && percentage.compareTo(BigDecimal.valueOf(100)) < 0;
    }

    @Override
    public BigDecimal calculateDiscount(BigDecimal originalAmount) {
        if (!isValid()) {
            throw new InvalidDiscountException("할인율이 유효하지 않습니다");
        }
        return originalAmount.multiply(percentage).divide(BigDecimal.valueOf(100));
    }
}

public class CouponDiscount extends AbstractDiscountPolicy {
    private final String couponCode;
    private final BigDecimal discountAmount;
    private final boolean isExpired;

    public CouponDiscount(Long orderId, String couponCode, BigDecimal discountAmount, boolean isExpired) {
        super(orderId);
        this.couponCode = couponCode;
        this.discountAmount = discountAmount;
        this.isExpired = isExpired;
    }

    @Override
    public boolean isValid() {
        return !isExpired && discountAmount.compareTo(BigDecimal.ZERO) > 0;
    }

    @Override
    public BigDecimal calculateDiscount(BigDecimal originalAmount) {
        if (!isValid()) {
            throw new InvalidDiscountException("쿠폰이 유효하지 않습니다");
        }
        return discountAmount.min(originalAmount);
    }
}
```

서비스 계층에서는 DiscountPolicy 목록을 통해 총 할인액을 계산합니다:

```java
@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final DiscountPolicyRepository discountPolicyRepository;

    public Order createOrder(String orderNumber, BigDecimal amount) {
        return orderRepository.save(new Order(UUID.randomUUID(), orderNumber, amount));
    }

    public BigDecimal getOrderTotal(Long orderId) {
        Order order = orderRepository.findById(orderId);
        List<DiscountPolicy> discountPolicies = discountPolicyRepository.findByOrderId(orderId);

        BigDecimal totalDiscount = BigDecimal.ZERO;
        for (DiscountPolicy policy : discountPolicies) {
            if (policy.isValid()) {
                totalDiscount = totalDiscount.add(policy.calculateDiscount(order.getOriginalAmount()));
            }
        }

        return order.calculateFinalAmount(totalDiscount);
    }
}
```

DiscountPolicy 도메인은 **역할과 책임 중심**으로 설계됩니다. 구현체 별로 필요한 필드만 가지고 있고, 구현체 별로 필요한 역할에만 충실하게 구현됩니다.

**Before와 After의 차이:**

| 측면          | Before (JPA 엔티티)  | After (도메인)          |
| ----------- | ----------------- | -------------------- |
| **필드**      | 모든 할인 방식 필드 포함    | 필요한 필드만              |
| **Null 처리** | 미사용 필드는 null      | 항상 의미 있는 값           |
| **확장성**     | 할인 정책 추가 시 엔티티 수정 | 새 클래스만 추가 (개방-폐쇄 원칙) |
| **테스트**     | 복잡한 세팅 필요         | 간단한 생성자 호출           |
| **책임**      | 데이터 저장 + 비즈니스 로직  | 비즈니스 로직만             |

이제 그럼 하나의 테이블에 모든 데이터가 있는 저 테이블 구조에서 어떻게 위 같이 도메인으로 분리할 수 있는지 알아보겠습니다.

---

### 영속성 레이어에서의 추상화 처리

이제 할인 정보가 모두 한 테이블에 저장되어 있는 경우 어떻게 도메인으로 매핑할 수 있는지 알아봅시다.
먼저 DiscountPolicyEntity를 한 테이블에 모든 필드를 저장합니다:

```java
@Entity
@Table(name = "discount_policies")
public class DiscountPolicyEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String policyType;  // FIXED, PERCENTAGE, COUPON
    private BigDecimal amount;
    private String couponCode;
    private boolean isExpired;
}
```

`DiscountPolicyRepository`에서 `OrderId`로 Entity 목록을 찾아 `DiscountPolicy` 구현체 목록으로 변환합니다:

```java
public interface DiscountPolicyRepository {
    List<DiscountPolicy> findByOrderId(Long orderId);
}

@Repository
public class DiscountPolicyRepositoryImpl implements DiscountPolicyRepository {
    private final DiscountPolicyJpaRepository jpaRepository;

    @Override
    public List<DiscountPolicy> findByOrderId(Long orderId) {
        List<DiscountPolicyEntity> entities = jpaRepository.findByOrderId(orderId);

        return entities.stream()
            .map(this::buildDiscountPolicy)
            .collect(Collectors.toList());
    }

    // Entity를 적절한 DiscountPolicy 구현체로 변환
    private DiscountPolicy buildDiscountPolicy(DiscountPolicyEntity entity) {
        switch(entity.getPolicyType()) {
            case "FIXED":
                return new FixedAmountDiscount(entity.getOrderId(), entity.getAmount());
            case "PERCENTAGE":
                return new PercentageDiscount(entity.getOrderId(), entity.getPercentage());
            case "COUPON":
                return new CouponDiscount(entity.getOrderId(),
                                        entity.getCouponCode(),
                                        entity.getAmount(),
                                        entity.isExpired());
            default:
                throw new IllegalArgumentException("Unknown policy type: " + entity.getPolicyType());
        }
    }
}

@Repository
public interface DiscountPolicyJpaRepository extends JpaRepository<DiscountPolicyEntity, Long> {
    List<DiscountPolicyEntity> findByOrderId(Long orderId);
}
```

---

나중에 성능 최적화를 위해 할인 정책을 타입별로 테이블을 분리한다고 해봅시다.
데이터베이스의 구조가 바뀌었는데 서비스 로직은 어떨까요?

```java
// 고정금액 할인 테이블
@Entity
@Table(name = "fixed_discount_policies")
public class FixedDiscountPolicyEntity {
    @Id
    private Long id;
    private Long orderId;
    private BigDecimal amount;
}

// 정률 할인 테이블
@Entity
@Table(name = "percentage_discount_policies")
public class PercentageDiscountPolicyEntity {
    @Id
    private Long id;
    private Long orderId;
    private BigDecimal percentage;
}

// 쿠폰 할인 테이블
@Entity
@Table(name = "coupon_discount_policies")
public class CouponDiscountPolicyEntity {
    @Id
    private Long id;
    private Long orderId;
    private String couponCode;
    private BigDecimal discountAmount;
    private boolean isExpired;
}
```

---

**DiscountPolicyRepository의 findByOrderId() 메서드만 변경하면 됩니다.**

DiscountPolicyRepository의 구현체의 `findByOrderId()` 메서드만 변경하면 됩니다:

```java
@Repository
public class DiscountPolicyRepositoryImpl implements DiscountPolicyRepository {
    private final FixedDiscountPolicyJpaRepository fixedRepository;
    private final PercentageDiscountPolicyJpaRepository percentageRepository;
    private final CouponDiscountPolicyJpaRepository couponRepository;

    @Override
    public List<DiscountPolicy> findByOrderId(Long orderId) {
		// 레포지토리들에서 OrderId에 해당하는 엔티티 조회
		
		// 엔티티 들을 도메인으로 변환
		
		// 변환한 도메인들을 List형식으로 return
    }
}
```

---

**주목할 점은 도메인과 서비스는 전혀 변경되지 않는 것입니다.**

```
DB 스키마 변경:
  - discount_policies (하나의 테이블)
    ↓
  - fixed_discount_policies, percentage_discount_policies, coupon_discount_policies (타입별 테이블)

영속성 레이어 변경:
  - DiscountPolicyRepositoryImpl.findByOrderId() 메서드만 수정

도메인 계층:
  - Order (OrderId를 매개변수로 받지 않음, 순수한 주문 데이터만 포함)
  - DiscountPolicy (OrderId를 간접 참조)
  - FixedAmountDiscount, PercentageDiscount, CouponDiscount
  - ✅ 변경 없음

서비스 계층:
  - OrderService (DiscountPolicyRepository.findByOrderId()로만 조회)
  - ✅ 변경 없음
```

이것이 바로 **레이어 분리의 힘**입니다! 다음과 같은 특징이 있습니다:

1. **Order는 DiscountPolicy를 모름**: Order 도메인은 할인 정책이 어떻게 저장되는지 전혀 관심 없음
2. **DiscountPolicy가 OrderId를 참조**: 할인 정책이 자신이 속한 주문을 알고 있음
3. **영속성 레이어만 변경**: `DiscountPolicyRepository.findByOrderId()`만 수정하면 DB 구조 변경을 완전히 흡수
4. **도메인 무변**: Order와 모든 DiscountPolicy 구현체의 코드는 건드리지 않음

---

### JPA와 도메인객체를 동일하게 사용했을때 문제

JPA 엔티티는 RDB의 테이블구조를 따라 갈 수 밖에 없기 때문에 데이터 중심의 설계가 될 수 밖에 없습니다.
데이터 중심 설계에서는 아래와 같이 모든 할인 방식을 하나의 엔티티에 넣고 메서드에서 처리해야 하므로 복잡합니다.

```java
// JPA 엔티티 - 데이터 중심
public BigDecimal calculateFinalAmount() {
    if ("FIXED".equals(discountType)) {
        return totalAmount.subtract(fixedDiscountAmount);
    } else if ("PERCENTAGE".equals(discountType)) {
        return totalAmount.multiply(BigDecimal.ONE.subtract(percentageDiscount.divide(BigDecimal.valueOf(100))));
    } else if ("COUPON".equals(discountType)) {
        // 쿠폰 유효성 확인 로직
        if (isCouponExpired(couponCode)) {
            return totalAmount;
        }
        return totalAmount.subtract(fixedDiscountAmount);
    }
    return totalAmount;
}
```

이는 객체지향 원칙을 위반하며, 새로운 할인 정책이 추가될 때마다 이 메서드를 수정해야 합니다. 이를 **Open-Closed Principle(확장에는 열려있고 수정에는 닫혀있어야 한다)** 위반이라고 합니다.

또한, DiscountPolicy의 DB 테이블 구조가 변경 된다라고 하면 모든 비즈니스 로직을 수정해야합니다.

---

## 3. final 키워드를 활용하여 도메인을 불변으로 설계할 수 있다

JPA 엔티티는 **final 키워드를 붙일 수 없습니다.** Hibernate가 프록시 객체를 생성하기 위해 서브클래싱을 필요로 하기 때문입니다. 이로 인해 JPA 엔티티는 **CQS(Command Query Separation) 원칙**을 지키기 어렵습니다.

**Before: JPA 엔티티의 제약**
```java
@Entity
@Getter
public class Order {
    @Id
    private Long id;
    private String orderNumber;
    private BigDecimal totalAmount;

    public Order() {}

    public Order(String orderNumber, BigDecimal totalAmount) {
        this.orderNumber = orderNumber;
        this.totalAmount = totalAmount;
    }
}
```

이로 인해 다음과 같은 문제가 발생합니다:

**JPA 엔티티에서의 CQS 원칙 위반 사례**
```java
@Entity
public class Order {
    private BigDecimal totalAmount;
    private int quantity;

    // 할인을 적용하는 메서드 - 조회와 명령이 섞여있음
    public void applyDiscount(BigDecimal discountPercent) {
        // 이 메서드는 상태를 변경함 (setter처럼 동작)
        totalAmount = totalAmount.multiply(BigDecimal.ONE.subtract(discountPercent));
    }

    // 또는 boolean을 반환하지만 상태도 변경
    public boolean discountApply(BigDecimal discountPercent) {
        if (totalAmount.compareTo(BigDecimal.ZERO) <= 0) {
            return false;  // 조회
        }
        totalAmount = totalAmount.multiply(BigDecimal.ONE.subtract(discountPercent));  // 명령
        return true;
    }
}
```

메서드의 의도가 불명확합니다. `discountApply()`를 호출하는 것만으로는 이 메서드가 상태를 변경하는지 알 수 없습니다.

---

**After: 도메인 객체는 불변으로 설계**

final 키워드를 사용하면 도메인을 불변 객체로 만들고, 자연스럽게 CQS 원칙을 따를 수 있습니다:
```java
public class Order {
    private final Long id;
    private final String orderNumber;
    private final BigDecimal totalAmount;
    private final int quantity;
    private final LocalDateTime createdAt;

    public Order(Long id, String orderNumber, BigDecimal totalAmount, int quantity) {
        this.id = id;
        this.orderNumber = orderNumber;
        this.totalAmount = totalAmount;
        this.quantity = quantity;
        this.createdAt = LocalDateTime.now();
    }

    public Order applyDiscount(BigDecimal discountPercent) {
        if (totalAmount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("할인할 수 없는 주문입니다");
        }

        BigDecimal discountedAmount = totalAmount.multiply(
            BigDecimal.ONE.subtract(discountPercent)
        );
        return new Order(this.id, this.orderNumber, discountedAmount, this.quantity);
    }

    public boolean canApplyDiscount(BigDecimal discountPercent) {
        return totalAmount.compareTo(BigDecimal.ZERO) > 0
            && discountPercent.compareTo(BigDecimal.ZERO) > 0
            && discountPercent.compareTo(BigDecimal.ONE) < 0;
    }

    public BigDecimal getTotalAmount() { return totalAmount; }
    public String getOrderNumber() { return orderNumber; }
}
```

final 키워드를 사용하면 불변 객체가 되고, CQS 원칙을 명확하게 지킬 수 있습니다:

- **조회(Query)**: `canApplyDiscount()` - 할인 가능 여부만 확인하고 상태는 변경하지 않음
- **명령(Command)**: `applyDiscount()` - 새로운 Order 객체를 반환

서비스 계층에서는 이를 명확하게 구분해서 사용합니다:

```java
@Service
public class OrderService {
    private final OrderRepository orderRepository;

    public Order applyDiscount(Long orderId, BigDecimal discountPercent) {
        Order order = orderRepository.findById(orderId);

        // 1단계: 조회 - 할인을 적용할 수 있는지 확인
        if (!order.canApplyDiscount(discountPercent)) {
            throw new InvalidDiscountException("할인을 적용할 수 없습니다");
        }

        // 2단계: 명령 - 새로운 Order 객체 생성 (원본은 변경되지 않음)
        Order discountedOrder = order.applyDiscount(discountPercent);

        // 3단계: 저장
        return orderRepository.save(discountedOrder);
    }
}
```

final 키워드를 통해 CQS를 강제함으로써 개발자가 예상하치 못한 상태 변경으로 인한 ==부수효과(side effect)==를 사전에 방지할 수 있습니다.

---

# 멀티모듈 구조로 레이어 의존성 강제하기

지금까지 살펴본 개념들은 같은 모듈 내에서도 구현 가능합니다. 하지만 **멀티모듈 구조**를 활용하면 **컴파일 타임에 아키텍처 의존성을 강제**할 수 있습니다. 이렇게 하면 팀원 모두가 올바른 아키텍처를 자동으로 따르게 됩니다.

## 멀티모듈의 구조

프로젝트를 아래와 같이 모듈로 분리합니다:

```
order-service/
├── order-domain          (도메인 레이어)
├── order-service         (서비스 레이어)
├── order-mariadb     (영속성 레이어)
└── order-application     (프레젠테이션 레이어)
```

## 의존성 관계 설정

**order-application** (프레젠테이션 레이어):
```gradle
dependencies {
    implementation project(':order-service')
}
```

**order-service** (서비스 레이어):
```gradle
dependencies {
    implementation project(':order-domain')
    runtimeOnly project(':order-mariadb')
}
```

**order-mariadb** (영속성 레이어):
```gradle
dependencies {
    implementation project(':order-domain')
}
```

**order-domain** (도메인 레이어):
```gradle
dependencies {
    // 외부 라이브러리에만 의존 (JPA, Spring 등과 무관)
}
```

## runtimeOnly 의존성

가장 중요한 부분은 **order-service에서 order-mariadb모듈을 runtimeOnly로 설정**하는 것입니다:

```gradle
// order-service/build.gradle
dependencies {
    implementation project(':order-domain')
    runtimeOnly project(':order-persistence')  // ← 여기가 핵심!
}
```

이렇게 설정하면:

- **컴파일 타임**: order-service는 order-persistence의 클래스를 import할 수 없음 (IDE에서 빨간 줄)
- **런타임**: 스프링의 의존성 주입이 자동으로 OrderRepository 구현체를 찾아 주입함

주문 서비스를 예시로 들어봅시다.
누군가 다른 팀원이 `OrderService`에서 `OrderRepositoryImpl` 를 직접 호출하려고 해서 아키텍처의 규칙을 어길려고 한다고 가정합시다.

```java
// ❌ 이 코드는 컴파일 에러 발생
@Service
public class OrderService {
    private final OrderRepositoryImpl orderRepositoryImpl;  // 컴파일 에러!

    public OrderService(OrderRepositoryImpl orderRepositoryImpl) {
        this.orderRepositoryImpl = orderRepositoryImpl;
    }
}
```


위 코드는 컴파일 에러가 발생합니다. 
왜냐하면 order-mariadb는 runtimeOnly 의존성이므로, order-service가 컴파일될 때 OrderRepositoryImpl 클래스를 찾을 수 없기 때문입니다.

대신 **인터페이스에만 의존**해야 합니다:

```java
// ✅ 올바른 코드
@Service
public class OrderService {
    private final OrderRepository orderRepository;  // 인터페이스 사용

    public OrderService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }
}
```

멀티모듈 구조와 `runtimeOnly`를 함께 사용하면, 팀원들 중 누군가 실수로 persistance 레이어의 객체를 사용해서 구현체에 의존하게 만드는 실수를 컴파일 레벨에서 잡을 수 있습니다.

## 실제 구현 예시

### 1. order-domain 모듈 (도메인)

```java
// 도메인 객체 (프레임워크에 무관)
public class Order {
    private final Long id;
    private final String orderNumber;
    private final BigDecimal originalAmount;
    private final DiscountPolicy discountPolicy;
    private final LocalDateTime createdAt;

    public Order(Long id, String orderNumber, BigDecimal originalAmount, DiscountPolicy discountPolicy) {
        this.id = id;
        this.orderNumber = orderNumber;
        this.originalAmount = originalAmount;
        this.discountPolicy = discountPolicy;
        this.createdAt = LocalDateTime.now();
    }

    public BigDecimal getFinalAmount() {
        if (discountPolicy.isValid()) {
            BigDecimal discount = discountPolicy.calculateDiscountAmount(originalAmount);
            return originalAmount.subtract(discount);
        }
        return originalAmount;
    }

    public String getOrderNumber() { return orderNumber; }
    public BigDecimal getOriginalAmount() { return originalAmount; }
}

public interface OrderRepository {
    Order save(Order order);
    Order findById(Long id);
}

```

### 2. order-service 모듈 (서비스)

```java
// 서비스는 도메인과 인터페이스에만 의존
@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final DiscountPolicyRepository discountPolicyRepository;

    public OrderService(OrderRepository orderRepository, DiscountPolicyRepository discountPolicyRepository) {
        this.orderRepository = orderRepository;
        this.discountPolicyRepository = discountPolicyRepository;
    }

    public Order createOrder(String orderNumber, BigDecimal amount) {
        Order order = new Order(UUID.randomUUID(), orderNumber, amount);
        return orderRepository.save(order);
    }

    public Order getOrder(Long orderId) {
        return orderRepository.findById(orderId);
    }

    // 특정 주문의 할인 정책들을 조회
    public List<DiscountPolicy> getDiscountPolicies(Long orderId) {
        return discountPolicyRepository.findByOrderId(orderId);
    }

    // 총 할인액 계산
    public BigDecimal calculateTotalDiscount(Long orderId, BigDecimal originalAmount) {
        List<DiscountPolicy> policies = discountPolicyRepository.findByOrderId(orderId);
        return policies.stream()
            .filter(DiscountPolicy::isValid)
            .map(policy -> policy.calculateDiscountAmount(originalAmount))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}
```

여기서 중요한 점은 `OrderRepository`와 `DiscountPolicyRepository` 인터페이스를 주입받지만, 실제 구현체가 뭔지 **알 필요가 없다**는 것입니다. order-persistence 모듈의 존재 자체를 모르고, 인터페이스를 통해서만 데이터에 접근합니다.

### 3. order-mariadb 모듈 (영속성 레이어)

```java
// JPA 엔티티 (영속성 레이어에만 존재)
@Entity
@Table(name = "orders")
@Getter
@Setter
public class OrderEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String orderNumber;
    private BigDecimal originalAmount;
    private LocalDateTime createdAt;
}

// 도메인 리포지토리의 구현체 (spring-data-jpa)
@Repository
public class OrderRepositoryImpl implements OrderRepository {
    private final OrderJpaRepository jpaRepository;

    public OrderRepositoryImpl(OrderJpaRepository jpaRepository) {
        this.jpaRepository = jpaRepository;
    }

    @Override
    public Order save(Order order) {
        OrderEntity entity = new OrderEntity();
        entity.setOrderNumber(order.getOrderNumber());
        entity.setOriginalAmount(order.getOriginalAmount());
        entity.setCreatedAt(LocalDateTime.now());

        OrderEntity saved = jpaRepository.save(entity);
        return new Order(saved.getId(), saved.getOrderNumber(), saved.getOriginalAmount());
    }

    @Override
    public Order findById(Long id) {
        return jpaRepository.findById(id)
            .map(entity -> new Order(entity.getId(), entity.getOrderNumber(), entity.getOriginalAmount()))
            .orElseThrow();
    }
}

@Repository
public interface OrderJpaRepository extends JpaRepository<OrderEntity, Long> {
}

```

### 4. order-application 모듈 (프레젠테이션)

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    private final OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @PostMapping
    public OrderResponse createOrder(@RequestBody CreateOrderRequest request) {
        Order order = orderService.createOrder(request.getOrderNumber(), request.getAmount());
        return OrderResponse.from(order);
    }

    @GetMapping("/{orderId}")
    public OrderResponse getOrder(@PathVariable Long orderId) {
        Order order = orderService.getOrder(orderId);
        return OrderResponse.from(order);
    }
}
```

## 의존성 구조 시각화
![멀티모듈 아키텍쳐](/assets/images/posts/멀티모듈%20아키텍쳐2-1.png)